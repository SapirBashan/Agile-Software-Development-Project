Mini Project: Introduction to Software Engineering
Summary
This mini project focused on creating a renderer in Java, demonstrating software engineering methodologies in action. Key features included renderer development, input processing, rendering techniques, and user interaction. The project aimed to apply software engineering concepts, enhance Java skills, and deepen rendering knowledge.

Introduction
This project practically applied software engineering principles to develop a renderer, bridging theory with real-world application. Rendering involves generating visual output from input data, and this project explored rendering techniques, especially ray tracing, for realistic results.

Project Scope and Objectives
The project scope covered renderer development with geometries, lighting, and primitives. Objectives included geometry implementation, lighting effects, primitive support, unit and integration testing, and acceptance testing. UI and advanced rendering techniques were excluded.

Methodology
The project followed Object-Oriented Design (OOD) principles, Responsibility-Driven Design (RDD), and incorporated design patterns. Ray tracing techniques, avoidance of anti-patterns, and continual improvement were integral parts of the methodology.

Requirements Analysis
The project requirements were gathered and documented, including use cases, functional and non-functional requirements, and user scenarios.

System Design
The high-level system design featured OOD, RDD, and various design patterns. Architecture, data flow diagrams, and class diagrams were used to illustrate the design decisions.

Implementation
Java was used for implementation, and design patterns were applied to solve common problems. Challenges were addressed through code refactoring and iterative development.

Testing and Quality Assurance
Testing encompassed unit, integration, and acceptance testing. JUnit 5 facilitated unit tests, ensuring components functioned correctly. Integration tests verified module interactions, and acceptance tests validated the renderer against requirements. Quality assurance measures included code reviews, documentation, and refactoring.

Deployment and Maintenance
Deployment involved Java and IntelliJ, requiring no additional installations. User training wasn't needed due to the lack of user interaction. Future maintenance included introducing new classes, updates, and enhancements.

Performance Acceleration
Performance was enhanced through antialiasing, soft shadows, glossy surfaces, diffuse glass, depth of field, multi-threading, and adaptive supersampling techniques. These techniques improved rendering quality and speed.

For a shorter GitHub readme, consider focusing on the most essential points from each section, highlighting the project's purpose, methodologies, main features, and notable techniques implemented.

![antiAliasing](https://github.com/SapirBashan/Agile-Software-Development-Project/assets/99900812/51a57158-d655-4887-9c26-056ab8208f15)
![bloryGlass](https://github.com/SapirBashan/Agile-Software-Development-Project/assets/99900812/1cab1c72-36aa-4e69-894e-52c8de7b4259)
![Glass](https://github.com/SapirBashan/Agile-Software-Development-Project/assets/99900812/423cfe85-a4a1-460d-b600-90550f7c0d6b)
![lightSphereSpotSharp](https://github.com/SapirBashan/Agile-Software-Development-Project/assets/99900812/f9675019-8f3a-4530-b850-13c12d414191)
![teapot](https://github.com/SapirBashan/Agile-Software-Development-Project/assets/99900812/a4b42c62-71f9-472b-ac02-8e3136585eba)
